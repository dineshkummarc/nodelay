<!DOCTYPE html>
<html>
    <head>
        <title>Nodelay</title>
        <script type="text/javascript" src="protovis/protovis-r3.2.js"></script>
        <!-- these three files are for Flash websocket support -->
        <script type="text/javascript" src="web-socket-js/swfobject.js"></script>
        <script type="text/javascript" src="web-socket-js/FABridge.js"></script>
        <script type="text/javascript" src="web-socket-js/web_socket.js"></script>        
        <script type="text/javascript">

        // these globals are for the Flash WebSocket implementation
        WEB_SOCKET_SWF_LOCATION = "web-socket-js/WebSocketMain.swf";
        WEB_SOCKET_DEBUG = true;
        
        var url, message, status;
        
        var minRetryWait = 5000,
            retryWait = minRetryWait, 
            maxRetryWait = 60000;
        
        window.onload = function() {

            url = "ws://"+document.location.host+":8080";
            
            messages = document.getElementById('messages');
            status = document.getElementById('status');
            
            status.innerHTML = "Connecting...";
            
            var ws = new WebSocket(url);
            setUpEvents(ws);
         
            initVis();
         
        }
        
        function setUpEvents(ws) {
        
            ws.onclose = function() {
                status.innerHTML = "WebSocket closed, retrying in " + Math.round(retryWait/1000) + " seconds!";                
                setTimeout(function() {
                    status.innerHTML = "Reconnecting...";                
                    var retryWs = new WebSocket(url);
                    setUpEvents(retryWs);
                }, retryWait);
                retryWait *= 2;
                retryWait = Math.min(maxRetryWait, retryWait);
            };

            ws.onerror = function() {
                status.innerHTML = "Error with WebSocket, try refreshing?";
            };

            ws.onopen = function() {
                status.innerHTML = "Connected! Waiting for messages...";
                retryWait = minRetryWait;
            };
            
            ws.onmessage = function(evt) {
                if (status.innerHTML == "Connected! Waiting for messages...") {
                    status.innerHTML = "";
                }            
                var edit = JSON.parse(evt.data);
                processEdit(edit);                
                var li = document.createElement('li');
                li.innerHTML = formatEdit(edit);
                messages.appendChild(li);
                if (messages.children.length > 20) {
                    messages.removeChild(messages.firstChild);
                }
            }
            
            // TODO: let's try reconnecting if the socket closes or hangs?
            
        }
        
        function formatEdit(edit) {
            var out = "<a href=\""+edit.url+"\">"+edit.title+"<\/a> " + edit.change + " " + edit.text
            // Add types from metaweb
            if (edit.types) {
                var typetext = [];
                for (var i = 0, l = edit.types.length; i < l; i++) {
                    var type = edit.types[i];
                    typetext.push(type.text);
                }
                out += '. Types: ' + typetext.join(', ');
            }
            // Add wikipedia metadata
            if (edit.metadata) {
                for (var pageid in edit.metadata.pages) {
                    var page = edit.metadata.pages[pageid];
                    out += '. Modified: ' + page.touched + ', Views: ' + page.counter + ', Size: ' + page.length;
                }
            }
            return out;
        }
        
        var types = [];
        var typeIndex = {};
        var groupNodes = {};
        
        function processEdit(edit) {
            
            var group = 0,
                groupNode;
            if (edit.types && edit.types.length > 0) {
                if (!(edit.types[0].id in typeIndex)) {
                    types.push(edit.types[0].id);
                    typeIndex[edit.types[0].id] = types.length;
                    // create a node for this type:
                    groupNode = { nodeName: edit.types[0].text, group: types.length, type: edit.types[0].id, nodeIndex: nodes.length };
                    groupNodes[edit.types[0].id] = groupNode;
                    nodes.push(groupNode);
                }
                group = typeIndex[edit.types[0].id];
                groupNode = groupNodes[edit.types[0].id];
            }
                        
            var node = { nodeName: edit.title, group: group, nodeIndex: nodes.length, lastTouched: Date.now() };
            nodes.push(node)
            
            if (groupNode) {
                groupNode.lastTouched = Date.now();
                links.push({ source: groupNode.nodeIndex, target: node.nodeIndex, value: 5 });
            }
                        
            // keep nodes to a manageable length, remove oldest one that isn't a type
            while (nodes.length > 100) {
                console.log('removing a node (length=' + nodes.length + ')');
            
                var sortedNodes = nodes.slice();
                sortedNodes.sort(function(a,b) {
                    return a.lastTouched - b.lastTouched;
                });
                var dead = sortedNodes[0];
                // remove this node
                nodes.splice(dead.nodeIndex, 1);
                console.log('removed a node (length=' + nodes.length + ')');
                // correct node index:
                // TODO: this could be smarter with a slice, no?
                nodes.forEach(function(n,i) {
                    n.nodeIndex = i;
                });
                
                // cleanup the groupNodes and types
                if (dead.type) {
                    // TODO: clean up the 'group' index
                    types.splice(types.indexOf(dead.type),1);
                    delete typeIndex[dead.type];
                    delete groupNodes[dead.type];
                }
                
                // decrement source and target index and remove invalid links
                links = links.filter(function(link) {
                    if (link.source == dead.nodeIndex || link.target == dead.nodeIndex) {
                        return false;
                    }
                    if (link.source > dead.nodeIndex) {
                        link.source -= 1;
                    }
                    if (link.target > dead.nodeIndex) {
                        link.target -= 1;
                    }
                    return true;
                });
            }
            
            console.log('nodes: ' + nodes.length);
            console.log('links: ' + links.length);
            
            if (force) {
                force.reset();
                vis.render();
            }
        }
        
        var force, vis;
        var nodes = [];
        var links = [];
        
        function initVis() {

            var container = document.getElementById('vis'),
                colors = pv.Colors.category10();
            
            vis = new pv.Panel()
                .canvas('vis')
                .width(function() { return container.offsetWidth })
                .height(function() { return container.offsetHeight })
                .fillStyle('rgba(0,0,0,0.01)')
                .event("mousedown", pv.Behavior.pan())
                .event("mousewheel", pv.Behavior.zoom());
            
            force = vis.add(pv.Layout.Force)
                .nodes(function() { return nodes })
                .links(function() { return links })
                .springConstant(0.2);
            
            force.link.add(pv.Line);
            
            force.node.add(pv.Dot)
                .size(function(d) { return Math.sqrt(d.linkDegree * (d.type ? 100 : 10)) /* Math.pow(this.scale, -1.5)*/ })
                .fillStyle(function(d) { return d.fix ? "brown" : colors(d.group) })
                .strokeStyle(function(d) { return d.type ? 'white' : this.fillStyle().brighter() })
                .lineWidth(1)
                .title(function(d) { return d.nodeName })
                .event("mousedown", pv.Behavior.drag())
                .event("drag", force);
            
            vis.render();
            
            window.onresize = function() {
                vis.render();
            }
        
        }
        
        </script>
        <style type="text/css">
            body {
                background: #444;
                color: white;
                margin: 20px;
                font: 14px/1.2 Helvetica, sans-serif;
            }
            a {
                color: yellow;
            }
            img#doggy {
                margin-left: 10px;
                margin-bottom: 20px;
                border-right: 1px solid white;
                border-bottom: 1px solid white;
            }
            h1, h2 {
                color: #00ff99;
                text-shadow: 3px 3px 8px #000;
            }
            #vis {
                width: 100%;
                height: 500px;
                background: #333;
                border-left: 1px solid #444;
                border-top: 1px solid #444;
                border-right: 1px solid #444;
                border-bottom: 1px solid #444;
                box-shadow:inset 2px 2px 8px #222;
                -moz-box-shadow:inset 2px 2px 8px #222;
                -webkit-box-shadow:inset 2px 2px 8px #222;
            }
        </style>
    </head>
    <body>
        <h1>Nodelay!</h1>
        <p>This page shows recent edits to the English language wikipedia, <em>right now</em>.</p>
        <p id="status"></p>
        <div id="vis">
        </div>
        <ul id="messages">
        </ul>
        <img id="doggy" src="images/nodelayKnockout.jpg" align="right">
        <h2>What / Why / How?</h2>
        <p>You're looking at team Nodelay's entry into <a href="http://nodeknockout.com/">Node Knockout</a>, a 48hr programming contest to explore <a href="http://nodejs.org/">node.js</a>.  We chose to explore stream processing and see how may different disparate data sources we could mash into the stream.</p>
        <p>So far we're using <a href="http://github.com/gf3/Jerk/">Jerk</a>, <a href="http://github.com/miksago/node-websocket-server">node-websocket-server</a> <a href="http://github.com/cloudhead/node-static">node-static</a> and <a href="http://howtonode.org/step-of-conductor">Step</a> to help parallelize HTTP requests. We borrowed a bit of <a href="http://www.jibble.org/pircbot.php">Pircbot</a> to strip formatting information. WebSockets seem to be working in Firefox thanks to a bit of Flash glue from <a href="http://github.com/gimite/web-socket-js/">web-socket-js</a> and a good old fashioned <a href="http://github.com/waywardmonkeys/netty-flash-crossdomain-policy-server/blob/master/sample_flash_policy.xml">socket policy file</a> on port 843.</p>
        <p>We're listening to the English <a href="http://meta.wikimedia.org/wiki/IRC_Channels#Recent_changes">Wikipedia IRC server</a> for update notifications.  For each update, we request the page edit metadata using the <a href="http://www.mediawiki.org/wiki/API">Wikipedia APIs</a> and load additional semantic category data from <a href="http://www.freebase.com/docs/data">Metaweb's Freebase</a>.  Finally, we return an annotated JSON object to the browser using the <a href="http://dev.w3.org/html5/websockets/">HTML5 Web Socket APIs</a>. Mashup-tastic!</p>
        <a href="http://nodeknockout.com/teams/nodelay" target="nko" title="Help me win Node.js KO!"><img style="position: fixed; top: 5px; right: 5px; border: 0px;" src="http://nodeknockout.com/images/voteko.png" alt="Help me win Node.js KO!" /></a>
    </body>
</html>
